"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+curves@1.2.0";
exports.ids = ["vendor-chunks/@noble+curves@1.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = a => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\nfunction equalBytes(b1, b2) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxHQUFHLEdBQUdDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDckIsTUFBTUMsR0FBRyxHQUFHRCxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLE1BQU1FLEdBQUcsR0FBR0YsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNyQixNQUFNRyxHQUFHLEdBQUlDLENBQUMsSUFBS0EsQ0FBQyxZQUFZQyxVQUFVO0FBQzFDLE1BQU1DLEtBQUssR0FBRyxlQUFnQkMsS0FBSyxDQUFDQyxJQUFJLENBQUM7RUFBRUMsTUFBTSxFQUFFO0FBQUksQ0FBQyxFQUFFLENBQUNDLENBQUMsRUFBRUMsQ0FBQyxLQUFLQSxDQUFDLENBQUNDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNwRztBQUNBO0FBQ0E7QUFDTyxTQUFTQyxVQUFVQSxDQUFDQyxLQUFLLEVBQUU7RUFDOUIsSUFBSSxDQUFDWixHQUFHLENBQUNZLEtBQUssQ0FBQyxFQUNYLE1BQU0sSUFBSUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDO0VBQzFDO0VBQ0EsSUFBSUMsR0FBRyxHQUFHLEVBQUU7RUFDWixLQUFLLElBQUlOLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0ksS0FBSyxDQUFDTixNQUFNLEVBQUVFLENBQUMsRUFBRSxFQUFFO0lBQ25DTSxHQUFHLElBQUlYLEtBQUssQ0FBQ1MsS0FBSyxDQUFDSixDQUFDLENBQUMsQ0FBQztFQUMxQjtFQUNBLE9BQU9NLEdBQUc7QUFDZDtBQUNPLFNBQVNDLG1CQUFtQkEsQ0FBQ0MsR0FBRyxFQUFFO0VBQ3JD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ZUFBY2tCLElBQUssRUFBQyxDQUFDO0lBQ2xHO0VBQ0osQ0FBQztFQUNELEtBQUssTUFBTSxDQUFDRCxTQUFTLEVBQUVDLElBQUksQ0FBQyxJQUFJSSxNQUFNLENBQUNDLE9BQU8sQ0FBQ1QsVUFBVSxDQUFDLEVBQ3RERSxVQUFVLENBQUNDLFNBQVMsRUFBRUMsSUFBSSxFQUFFLEtBQUssQ0FBQztFQUN0QyxLQUFLLE1BQU0sQ0FBQ0QsU0FBUyxFQUFFQyxJQUFJLENBQUMsSUFBSUksTUFBTSxDQUFDQyxPQUFPLENBQUNSLGFBQWEsQ0FBQyxFQUN6REMsVUFBVSxDQUFDQyxTQUFTLEVBQUVDLElBQUksRUFBRSxJQUFJLENBQUM7RUFDckMsT0FBT1YsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdHJlYW1wYXktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjIuMC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/M2QzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiRXJyb3IiLCJoZXgiLCJudW1iZXJUb0hleFVucGFkZGVkIiwibnVtIiwiaGV4VG9OdW1iZXIiLCJoZXhUb0J5dGVzIiwibGVuIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsInNsaWNlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsIm51bWJlclRvQnl0ZXNMRSIsIm51bWJlclRvVmFyQnl0ZXNCRSIsImVuc3VyZUJ5dGVzIiwidGl0bGUiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsInIiLCJyZWR1Y2UiLCJzdW0iLCJwYWQiLCJmb3JFYWNoIiwic2V0IiwiZXF1YWxCeXRlcyIsImIxIiwiYjIiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwidmFsdWUiLCJiaXRNYXNrIiwidThuIiwiZGF0YSIsInU4ZnIiLCJhcnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsImIiLCJyZXNlZWQiLCJzZWVkIiwiZ2VuIiwib3V0Iiwic2wiLCJwdXNoIiwiZ2VuVW50aWwiLCJwcmVkIiwidW5kZWZpbmVkIiwidmFsaWRhdG9yRm5zIiwiYmlnaW50IiwidmFsIiwiZnVuY3Rpb24iLCJib29sZWFuIiwic3RyaW5nIiwic3RyaW5nT3JVaW50OEFycmF5IiwiaXNTYWZlSW50ZWdlciIsImlzQXJyYXkiLCJmaWVsZCIsIm9iamVjdCIsIkZwIiwiaXNWYWxpZCIsImhhc2giLCJvdXRwdXRMZW4iLCJ2YWxpZGF0ZU9iamVjdCIsInZhbGlkYXRvcnMiLCJvcHRWYWxpZGF0b3JzIiwiY2hlY2tGaWVsZCIsImZpZWxkTmFtZSIsInR5cGUiLCJpc09wdGlvbmFsIiwiY2hlY2tWYWwiLCJTdHJpbmciLCJPYmplY3QiLCJlbnRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.2.0/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ })

};
;